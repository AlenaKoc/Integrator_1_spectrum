# ---------------------------------------------------------------------------
''' Written and tested by Alena Kochubei and Aleksei Marianov. 2021-2022'''
# ---------------------------------------------------------------------------

from importlib.resources import path
import os
import shutil
from typing import List, Any, Union

import pandas as pd
import numpy as np
import scipy.signal as sig
# from numpy.sig3re._multiarray_umath import ndarray
from matplotlib.backends._backend_tk import NavigationToolbar2Tk
from scipy.interpolate import interp1d
import matplotlib.pylab as pl
import peakutils
from tkinter import *
from matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg)  # could be added NavigationToolbar2Tk
from matplotlib.figure import Figure
# import matplotlib.pyplot as plt
# from struct import unpack
# import struct
import time
# import threading
from scipy.signal import savgol_filter

'''The program was created for an automatic analysis of the chromatograms obtained via batch measurements performed on Shimadzu GC-2014 with
LabSolutions software. It provides quick assesment and quite accurate integral values for the peaks with a high signal/noise ratio.

Tested with:

In the current configuration the program was tested and is working for the following types of txt files stored in the folders:
Txt files are created following the procedure:
    1) Labsolutions software(The software was installed for Shimadzu GC_2014) -> Data -> Postrun(part that allows manual integration) ->
    -> open the folder with your data
    2) Choose all the files you want to integrate -> press right button on the mouse -> File Conversion -> Convert to ASCII format
    3) Choose all the files you want to integrate again -> File -> Extract ->
    -> extract the info to txt ticking only Chromatogram pictogram for the info that should be extracted.
     
The program was created for the analysis of one Ar stream passing through ShinCarbon column to TCD detector. 
It shows the figures for 6 signals for 4 gases: H2, O2+N2, CO, CH4, CO2. O2 and N2 signals are not resolved. 
Two of the figures do not have any peaks, but can be used in case the system has additional peaks. 

Code description:

The initial functions are written for the class PeakFinder. First function is separating detecor1 and detector2 files based on the numbers in 
the titles of .txt files: even(detecor1), uneven(detector2). Next function
is extracting time and detector responses. The following functions cut the original data into the slices of interest, define peaks, baseline
and integration boundaries. Finally, the integrals are calculated using these data and the respective figures are generated.

An instance of a class Peakfinder is storing all of the data: time and detector_response slices of interest, peaks, baselines,
integration boundaries and, finally, the integrals. 

Gui object creates a software window. It contains entries for all the arguments that require an user input for an instance of a PeakFinder class. 
Also, it contains buttons that prompt figures generation for all the gases using 
plot_chromatogram(subplot: Any, slices: tuple, times_peaks: list, base_lines: list, peak_half_width: float, peak_distortion: float)
and exporting integrals into .xlsx file using export_data() function.

Issues:

In the case when simulated baseline is not linear within integration boundaries, the integrals can not be calculated in this software.
Those peaks should be integrated manually. Usually, it is an issue for small peaks with integrals < 5.'''

def _get_curves(directory:str) -> tuple:
    '''The function extracts two columns of the numerical data (type:float) from the txt files in folder. The parameters for np.genfromtxt(), 
    like skip_header and skip_footer are adjusted for the txt files generated by LabSolutions software using the following algorithm:
     1) Labsolutions software(The software was installed for Shimadzu GC_2014) -> Data -> Postrun(part that allows manual integration) ->
    -> open the folder with your data
    2) Choose all the files you want to integrate -> press right button on the mouse -> File Conversion -> Convert to ASCII format
    3) Choose all the files you want to integrate again -> File -> Extract ->
    -> extract the info to txt ticking only Chromatogram pictogram for the info that should be extracted.
    
    --------------------
    Returns
    --------------------
        time_slices, detector_responses
            Tuple compiled from lists containing times:np.array[float] and detector_responses:np.array[float]. 
            Numpy arrays are extracted from individual txt files ccontained in directory.
    
    -----------------
    Parameters
    ------------------
        directory:str
            path for the directory with txt files'''
    time_slices = []
    detector_responses = []

    for file in os.listdir(directory):
        if file.endswith('.txt'):
            path_in = os.path.join(f'{directory}\\{file}')
            vals = np.genfromtxt(path_in, usecols=(1), skip_header=106, skip_footer=4)
            times = np.genfromtxt(path_in, usecols=(0), skip_header=106, skip_footer=4)
            time_slices.append(np.array(times))
            detector_responses.append(np.array(vals))

    return time_slices, detector_responses


def cut_curves(curves: tuple, left_limit: float, right_limit: float) -> tuple:
    '''The function cuts out the parts of interest from the whole array.
    
    --------------------
    Returns
    --------------------
        time_slices, detector_responses
            Tuple compiled from lists of numpy arrays. Numpy arrays are cut from full_time numpy arrays obtained as 
            the return of the function _get_curves(directory:str).
    
    -----------------
    Parameters
    ------------------
        curves: tuple
            tuple of lists containing times:np.array[float] and detector_responses:np.array[float] from _get_curves(directory:str) function.
        left_limit: float
            float defining the minimum time of the slice.
        right_limit: float
            float defining the maximum time of the slice.'''
    time_slices = []
    detector_responses = []

    times, vals = curves

    for i, single_time in enumerate(times):
        if i <= len(times):
            left, right = (np.argmin(abs(times[i] - left_limit)), np.argmin(abs(times[i] - right_limit)))
            time_slice = times[i][left:right]
            time_slices.append(np.array(time_slice))
            signal_slice = (vals[i] - min(vals[i]))[left:right]
            detector_responses.append(np.array(signal_slice))

            i += 1

        else:
            break

    return time_slices, detector_responses


def _get_peaks(curves: tuple, small_peak_position: float, peak_prominence: float) -> tuple:
    '''The function finds the peaks i.e. the heighest point of the detector responses. It uses Savitzky-Golay filter (savgol_filter from 
    scipy.signal) for smoothing the curves. In the tested case (described at the beginning of the file) parameters 51 points and polynom of 5 
    are suitable. The scipy.signal.find_peaks is used for finding the peaks.
    The detector responses for peaks are above prominenece parameter which defines the difference between baseline and the detector response
    (height of the signal). In case there are no signals above the prominence, the small peak position (defined in time or any x axis unit by user) 
    is used for the peak position.
    !!!IMPORTANT!!! It is preferable to have only one peak per slice. 
    
    --------------------
    Returns
    --------------------
        peaks_x_vals, peaks_y_vals
            Tuple compiled from lists containing time:np.array[float] and detector_responses:np.array[float] of the peaks. 
            Peaks are found by smoothing the curve obtained from cut_curves(curves: tuple, left_limit: float, right_limit: float) 
            with Savitzky-Golay filter. Then, the scipy.signal.find_peaks for finding the peaks is applied. 
    
    -----------------
    Parameters
    ------------------
        curves: tuple
            tuple of lists containing times:np.array[float] and detector_responses:np.array[float] from 
            _cut_curves(curves: tuple, left_limit: float, right_limit: float) function.
        small_peak_position: float
            float defining the time for a peak smaller than peak_prominence.
        peak_prominence: float
            float defining the minimum difference between baseline and the detector response(height of the signal).'''
    times, signals = curves
    tiny_peaks = small_peak_position
    peaks_x_vals, peaks_y_vals = [], []
    for time1, signal in zip(times, signals):
        try:
            signal = savgol_filter(signal, 51, 5)
        except ValueError:
            break
        peaks = sig.find_peaks(signal, prominence=peak_prominence)[0]
        if len(peaks) == 0:
            peaks = [int(round(len(time1) * (tiny_peaks - min(time1))
                                  / (max(time1) - min(time1)), 0))]
        try:
            peaks_lst_y = [signal[x] for x in peaks]
            peaks_lst_x = [time1[x] for x in peaks]
            peaks_x_vals.append(np.array(peaks_lst_x))
            peaks_y_vals.append(np.array(peaks_lst_y))
        except IndexError:
            peaks_x_vals.append(max(time1))
            peaks_y_vals.append(signal[np.where(time1 == max(time1))])
    return peaks_x_vals, peaks_y_vals


def _get_integration_boundaries(peaks: tuple, curves: tuple, peak_half_width: float, peak_distortion:float) -> tuple:
    '''The function defines the limits (time:float) for the integration. Time: None if there is an error in defining the limit.
    !!!IMPORTANT!!! For reliable results, limits should be completely within previously defined _cut_curves() limits. 
    There is an opportunity to regulate manually the width of the integration region via defining peak_half_width parameter. 
    Also, the position of integration boundaries relative to the peak (heighest point) can be changed using peak_distortion arg 
    if the bell-shaped curve of the signal is elongated on the right or the left side.

    --------------------
    Returns
    --------------------
        bounds, err_lst
            Tuple of bounds:list[tuple(float, float) or tuple(None, None)] for a right and left limit of integration and err_lst[str]. 

    -----------------
    Parameters
    ------------------
        peaks: tuple, 
            a tuple of lists containing time:np.array[float] and detector_responses:np.array[float] of the peaks 
            from _get_peaks(curves: tuple, small_peak_position: float, peak_prominence: float).
        curves: tuple,
            tuple of times:np.array[float] and detector_responses:np.array[float] from 
            _cut_curves(curves: tuple, left_limit: float, right_limit: float) function. 
        peak_half_width: float,
            float defining the peak half width.
        peak_distortion:float
            float defining the distortion of the peak from an ideal bell-shaped curve.'''
    peaks_x, x_lines = peaks[0], curves[0]
    left_len = peak_half_width * peak_distortion
    right_len = peak_half_width / peak_distortion
    bounds = []
    err_lst = []
    for i, (x, line) in enumerate(zip(peaks_x, x_lines)):
        try:
            left_bound_arg = np.argmin(abs(line - (x - left_len)))
            right_bound_arg = np.argmin(abs(line - (x + right_len)))
            bounds.append((left_bound_arg, right_bound_arg))
        except ValueError:
            string = f'Integration failed: trace {i}, He line.'
            err_lst.append(string)
            left_bound_arg = None
            right_bound_arg = None
            bounds.append((left_bound_arg, right_bound_arg))
    return bounds, err_lst


def _get_baseline(curves: tuple, integration_boundaries: tuple, polynom_order: int) -> list:
    """ The function is producing a baseline from the parts of curves (_cut_curves()) within the integration boundaries 
    cut off from the arrays. The baseline is fitted with scipy.interpolate first. In case, it is unsuccessful, peakutils.baseline() is applied.
    Polynom order is used to improve the fit of a baseline.
    --------------------
    Returns
    --------------------
        baselines
            list of detector_responses:np.array[float] for the calculated baseline.

    -----------------
    Parameters
    ------------------
        curves: tuple,
            tuple of times:np.array[float] and detector_responses:np.array[float] from 
            _cut_curves(curves: tuple, left_limit: float, right_limit: float) function. 
        integration_boundaries: tuple,
            a tuple of bounds:list[tuple(float, float) or tuple(None, None)] for a right and left limit of integration and err_lst[str]
            from _get_integration_boundaries(peaks: tuple, curves: tuple, peak_half_width: float, peak_distortion:float).
            err_lst is not used in calculations. 
        polynom_order: int
            int defining the polynomial function order for baseline simulation.

    The function will ignore the errors in settings or broken files and continue regardless. The curves with bad configuration
    will be displayed but not integrated."""

    baselines = []

    for sign, t, bound in zip(curves[1], curves[0],
                              integration_boundaries[0]):

        try:
            index = range(int(bound[0]), int(bound[1]))
            sign = savgol_filter(sign, 17, 3)
            sign_sig3py = np.delete(sign, index)
            t_sig3py = np.delete(t, index)
            try:
                p = interp1d(t_sig3py, sign_sig3py, kind='linear')
            except ValueError:
                break
            try:
                baseline_no_peak = p(t)
            except ValueError:
                baseline_no_peak = sign_sig3py
            baseline = peakutils.baseline(baseline_no_peak, polynom_order)
            baselines.append(baseline)
        except TypeError:
            baseline = peakutils.baseline(sign, polynom_order)
            baselines.append(baseline)
    return baselines


def _integrate_peaks(integration_boundaries: tuple, baseline: list, curves: tuple) -> list:
    '''The function integrates the peaks obtained from _get_peaks(curves: tuple, small_peak_position: float, peak_prominence: float) 
    using integration boundaries obtained from the _get_integration_boundaries(peaks: tuple, curves: tuple, peak_half_width: float, 
    peak_offset:float). The y curves are smoothed using Savitzky-Golay filter (saavgol_filter from scipy.signal) prior to integration. 
    The integration is conducted using numpy.trapz().
    
    --------------------
    Returns
    --------------------
        peak_ints: list
            List of the integrals:float for the peaks defined in _get_peaks(curves: tuple, small_peak_position: float, peak_prominence: float). 
            Integration boundaries are also defined in another function  
            _get_integration_boundaries(peaks: tuple, curves: tuple, peak_half_width: float, peak_distortion:float).
    
    -----------------
    Parameters
    ------------------
        integration_boundaries: tuple,
            a tuple of bounds:list[tuple(float, float) or tuple(None, None)] for a right and left limit of integration and err_lst[str]
            from _get_integration_boundaries(peaks: tuple, curves: tuple, peak_half_width: float, peak_distortion:float).
            err_lst is not used in calculations.
        curves: tuple,
            tuple of times:np.array[float] and detector_responses:np.array[float] from 
            _cut_curves(curves: tuple, left_limit: float, right_limit: float) function.
        baselines
            list of detector_responses:np.array[float] for the calculated baseline 
            from _get_baseline(curves: tuple, integration_boundaries: tuple, polynom_order: int).'''

    bounds = integration_boundaries[0]
    baselines = baseline
    full_xs, full_ys = curves
    peak_ints = []
    for bound, baseline, full_x, full_y in zip(bounds, baselines, full_xs, full_ys):
        if bound[0]:
            background = baseline[bound[0]:bound[1]]
            x = (full_x[bound[0]:bound[1]]) * 60
            y = savgol_filter(full_y[bound[0]:bound[1]] - background, 41, 3)
            integral = np.trapz(y, x)
        else:
            integral = None
        peak_ints = np.append(peak_ints, integral)
    return peak_ints


def plot_chromatogram(subplot: Any, slices: tuple, times_peaks: list, base_lines: list, peak_half_width: float, peak_distortion: float) -> None:
    # plot_chromatogram(f_ax1, a.sig1_curves, a.sig1_peaks, a.sig1_baselines, sig1_peak_width, a.sig1_peak_offset)
    '''The function plots curves, peaks(markers), baselines(dashed lines) and integration boundaries(yellow lines) for all the curves in the
    folder. All the curves are separated by 20 units of detector response for a clear observation of each of them.

    !!!IMPORTANT!!! Function requires pre-existing subplot created using matplotlib for putting figure into it.
    
    --------------------
    Returns
    --------------------
        None
    
    -----------------
    Parameters
    -----------------
        subplot: Any, 
            a subplot created using matplotlib
        slices: tuple, 
            tuple of times:np.array[float] and detector_responses:np.array[float] from 
            _cut_curves(curves: tuple, left_limit: float, right_limit: float) function.
        times_peaks: list, 
            a tuple of lists containing time:np.array[float] and detector_responses:np.array[float] of the peaks 
            from _get_peaks(curves: tuple, small_peak_position: float, peak_prominence: float).
        base_lines: list, 
             list of detector_responses:np.array[float] for the calculated baseline 
            from _get_baseline(curves: tuple, integration_boundaries: tuple, polynom_order: int).
        peak_half_width: float,
            float defining the peak half width.
        peak_distortion:float
            float defining the distortion of the peak from an ideal bell-shaped curve.'''
    time_slices, signal_slices = slices
    times, peaks = times_peaks
    baselines = base_lines
    cmap = pl.cm.gist_heat(np.linspace(0, 0.8, len(time_slices)))

    [subplot.plot(time_slice, (signal_slice + i * 20) / 1000, lw=1, c=cmap[i]) for i, (time_slice, signal_slice)
     in enumerate(zip(time_slices, signal_slices))]

    for i, (time_slice, baseline) in enumerate(zip(time_slices, baselines)):
        try:
            subplot.plot(time_slice, (baseline + i * 20) / 1000, ls='--', lw=1, c=cmap[i])
        except ValueError:
            pass

    [subplot.plot(time1, (peak + i * 20) / 1000, ls='', marker='*', mec='black', mfc='black', ms=5)
     for i, (time1, peak) in enumerate(zip(times, peaks))]

    for i, (time1, baseline, time_stretch) in enumerate(zip(times, baselines, time_slices)):
        try:
            left_arg = np.argmin(abs(time_stretch - (time1 - float(peak_half_width) * float(peak_distortion))))
            right_arg = np.argmin(abs(time_stretch - (time1 + float(peak_half_width) / float(peak_distortion))))
            x = time_stretch[left_arg:right_arg]
            y = baseline[left_arg:right_arg]
            subplot.plot(x, (y + i * 20) / 1000, lw=1.5, c='yellow')
        except ValueError:
            pass
    subplot.set_ylabel('detector signal, mV')
    subplot.set_xlabel('time, min')
    subplot.set_facecolor('lavender')


start = time.time()


class PeakFinder:
    def __init__(self, batch_dir, sig1_left=3.6, sig1_right=4.7, sig1_baseline_polynom_order=5, sig1_peak_prominence=5.0,
                 sig1_peak_width=0.2, sig2_left=1.2, sig2_right=1.5, sig2_peak_prominence=0.5,
                 sig2_baseline_polynom_order=1, sig2_peak_width=0.1, sig1_peak_distortion=0.5, sig2_peak_distortion=0.5,
                 sig1_small_peaks_pos=4.9, sig2_small_peaks_pos=1.2, sig3_left=3.6, sig3_right=4.7, sig3_baseline_polynom_order=5,
                 sig3_peak_prominence=5.0, sig3_peak_width=0.2, sig4_left=1.2, sig4_right=1.5, sig4_peak_prominence=0.5,
                 sig4_baseline_polynom_order=1, sig4_peak_width=0.1, sig3_peak_distortion=0.5, sig4_peak_distortion=0.5,
                 sig3_small_peaks_pos=4.9, sig4_small_peaks_pos=1.2, sig5_left=3.6, sig5_right=4.7,
                 sig5_baseline_polynom_order=5, sig5_peak_prominence=5.0, sig5_peak_width=0.2, sig6_left=1.2,
                 sig6_right=1.5, sig6_peak_prominence=0.5, sig6_baseline_polynom_order=1, sig6_peak_width=0.1,
                 sig5_peak_distortion=0.5, sig6_peak_distortion=0.5, sig5_small_peaks_pos=4.9,
                 sig6_small_peaks_pos=1.2):
        '''The instance of Peakfinder class calculates and contains the curves, peaks, baselines, integration boundaries and integrals for the 
        specified folder of the txt files containing spectra/chromatograms.'''
        self.dir = batch_dir
        self.sig1_left = sig1_left
        self.sig1_right = sig1_right
        self.sig2_left = sig2_left
        self.sig2_right = sig2_right
        self.sig3_left = sig3_left
        self.sig3_right = sig3_right
        self.sig4_left = sig4_left
        self.sig4_right = sig4_right
        self.sig5_left = sig5_left
        self.sig5_right = sig5_right
        self.sig6_left = sig6_left
        self.sig6_right = sig6_right
        self.sig1_pol_order = sig1_baseline_polynom_order
        self.sig1_peak_prom = sig1_peak_prominence
        self.sig1_peak_width = sig1_peak_width
        self.sig2_peak_width = sig2_peak_width
        self.sig2_peak_prom = sig2_peak_prominence
        self.sig2_pol_order = sig2_baseline_polynom_order
        self.sig3_pol_order = sig3_baseline_polynom_order
        self.sig3_peak_prom = sig3_peak_prominence
        self.sig3_peak_width = sig3_peak_width
        self.sig4_peak_width = sig4_peak_width
        self.sig4_peak_prom = sig4_peak_prominence
        self.sig4_pol_order = sig4_baseline_polynom_order
        self.sig5_pol_order = sig5_baseline_polynom_order
        self.sig5_peak_prom = sig5_peak_prominence
        self.sig5_peak_width = sig5_peak_width
        self.sig6_peak_width = sig6_peak_width
        self.sig6_peak_prom = sig6_peak_prominence
        self.sig6_pol_order = sig6_baseline_polynom_order
        self.sig1_peak_offset = sig1_peak_distortion
        self.sig2_peak_offset = sig2_peak_distortion
        self.sig3_peak_offset = sig3_peak_distortion
        self.sig4_peak_offset = sig4_peak_distortion
        self.sig5_peak_offset = sig5_peak_distortion
        self.sig6_peak_offset = sig6_peak_distortion
        self.sig1_spp = sig1_small_peaks_pos
        self.sig2_spp = sig2_small_peaks_pos
        self.sig3_spp = sig3_small_peaks_pos
        self.sig4_spp = sig4_small_peaks_pos
        self.sig5_spp = sig5_small_peaks_pos
        self.sig6_spp = sig6_small_peaks_pos
        # self.curves = self.curves()
        # self.curves = self.curves()
        self.curves = self.curves()
        self.sig1_curves = self.sig1_curves()
        self.sig2_curves = self.sig2_curves()
        self.sig3_curves = self.sig3_curves()
        self.sig4_curves = self.sig4_curves()
        self.sig5_curves = self.sig5_curves()
        self.sig6_curves = self.sig6_curves()
        self.sig1_peaks = self.sig1_peaks()
        self.sig2_peaks = self.sig2_peaks()
        self.sig3_peaks = self.sig3_peaks()
        self.sig4_peaks = self.sig4_peaks()
        self.sig5_peaks = self.sig5_peaks()
        self.sig6_peaks = self.sig6_peaks()
        # self.sig1_ints, self.sig2_ints = self.sig1_ints(), self._integrate_sig2_peaks()
        self.sig1_integration_boundaries = self.sig1_integration_boundaries()
        self.sig2_integration_boundaries = self.sig2_integration_boundaries()
        self.sig3_integration_boundaries = self.sig3_integration_boundaries()
        self.sig4_integration_boundaries = self.sig4_integration_boundaries()
        self.sig5_integration_boundaries = self.sig5_integration_boundaries()
        self.sig6_integration_boundaries = self.sig6_integration_boundaries()
        self.sig1_baselines = self.sig1_baselines()
        self.sig2_baselines = self.sig2_baselines()
        self.sig3_baselines = self.sig3_baselines()
        self.sig4_baselines = self.sig4_baselines()
        self.sig5_baselines = self.sig5_baselines()
        self.sig6_baselines = self.sig6_baselines()
        self.sig1_integrals = self.sig1_ints()
        self.sig2_integrals = self.sig2_ints()
        self.sig3_integrals = self.sig3_ints()
        self.sig4_integrals = self.sig4_ints()
        self.sig5_integrals = self.sig5_ints()
        self.sig6_integrals = self.sig6_ints()

    def curves(self):
        return _get_curves(self.dir)

    print(1000 * (time.time() - start))

    def sig1_curves(self):
        return cut_curves(self.curves, self.sig1_left, self.sig1_right)

    def sig1_peaks(self):
        return _get_peaks(self.sig1_curves, self.sig1_spp, self.sig1_peak_prom)

    def sig1_integration_boundaries(self):
        return _get_integration_boundaries(self.sig1_peaks, self.sig1_curves, self.sig1_peak_width, self.sig1_peak_offset)

    def sig1_baselines(self):
        return _get_baseline(self.sig1_curves, self.sig1_integration_boundaries, self.sig1_pol_order)

    def sig1_ints(self):
        return _integrate_peaks(self.sig1_integration_boundaries, self.sig1_baselines, self.sig1_curves)

    print(1000 * (time.time() - start))

    def sig2_curves(self):
        return cut_curves(self.curves, self.sig2_left, self.sig2_right)

    def sig2_peaks(self):
        return _get_peaks(self.sig2_curves, self.sig2_spp, self.sig2_peak_prom)

    def sig2_integration_boundaries(self):
        return _get_integration_boundaries(self.sig2_peaks, self.sig2_curves, self.sig2_peak_width, self.sig2_peak_offset)

    def sig2_baselines(self):
        return _get_baseline(self.sig2_curves, self.sig2_integration_boundaries, self.sig2_pol_order)

    def sig2_ints(self):
        return _integrate_peaks(self.sig2_integration_boundaries, self.sig2_baselines, self.sig2_curves)

    def sig3_curves(self):
        return cut_curves(self.curves, self.sig3_left, self.sig3_right)

    def sig3_peaks(self):
        return _get_peaks(self.sig3_curves, self.sig3_spp, self.sig3_peak_prom)

    def sig3_integration_boundaries(self):
        return _get_integration_boundaries(self.sig3_peaks, self.sig3_curves, self.sig3_peak_width, self.sig3_peak_offset)

    def sig3_baselines(self):
        return _get_baseline(self.sig3_curves, self.sig3_integration_boundaries, self.sig3_pol_order)

    def sig3_ints(self):
        return _integrate_peaks(self.sig3_integration_boundaries, self.sig3_baselines, self.sig3_curves)

    def sig4_curves(self):
        return cut_curves(self.curves, self.sig4_left, self.sig4_right)

    def sig4_peaks(self):
        return _get_peaks(self.sig4_curves, self.sig4_spp, self.sig4_peak_prom)

    def sig4_integration_boundaries(self):
        return _get_integration_boundaries(self.sig4_peaks, self.sig4_curves, self.sig4_peak_width, self.sig4_peak_offset)

    def sig4_baselines(self):
        return _get_baseline(self.sig4_curves, self.sig4_integration_boundaries, self.sig4_pol_order)

    def sig4_ints(self):
        return _integrate_peaks(self.sig4_integration_boundaries, self.sig4_baselines, self.sig4_curves)

    def sig5_curves(self):
        return cut_curves(self.curves, self.sig5_left, self.sig5_right)

    def sig5_peaks(self):
        return _get_peaks(self.sig5_curves, self.sig5_spp, self.sig5_peak_prom)

    def sig5_integration_boundaries(self):
        return _get_integration_boundaries(self.sig5_peaks, self.sig5_curves, self.sig5_peak_width,
                                           self.sig5_peak_offset)

    def sig5_baselines(self):
        return _get_baseline(self.sig5_curves, self.sig5_integration_boundaries, self.sig5_pol_order)

    def sig5_ints(self):
        return _integrate_peaks(self.sig5_integration_boundaries, self.sig5_baselines, self.sig5_curves)

    def sig6_curves(self):
        return cut_curves(self.curves, self.sig6_left, self.sig6_right)

    def sig6_peaks(self):
        return _get_peaks(self.sig6_curves, self.sig6_spp, self.sig6_peak_prom)

    def sig6_integration_boundaries(self):
        return _get_integration_boundaries(self.sig6_peaks, self.sig6_curves, self.sig6_peak_width,
                                           self.sig6_peak_offset)

    def sig6_baselines(self):
        return _get_baseline(self.sig6_curves, self.sig6_integration_boundaries, self.sig6_pol_order)

    def sig6_ints(self):
        return _integrate_peaks(self.sig6_integration_boundaries, self.sig6_baselines, self.sig6_curves)


class Gui(object):
    def __init__(self, root1):
        '''Creates a frame for various inputs required for the calculations in the class Peakfinder and plotting the figures.'''
        self.root = root1
        self.entry = Entry(root1)
        root1.wm_title("Welcome to Jim's integration!")
        # image_path = os.getcwd() + '/image.png'
        # im = PhotoImage(file=image_path)
        # root.iconphoto(False, im)
        frame = Frame(self.root, borderwidth=5)
        frame.grid(row=0, column=0, sticky="n")

        Label(frame, text="Enter the sequence directory:").grid(row=0, column=0, sticky="nw")  # data_dir_label
        Label(frame, text="Enter the export directory:").grid(row=1, column=0, sticky="nw")  # xlsx_dir_label

        data_entry = Entry(frame)
        data_entry.grid(row=0, column=1, sticky=E)
        data_entry.insert(0, 'Sequence directory')
        xlsx_entry = Entry(frame)
        xlsx_entry.grid(row=1, column=1, sticky=E)
        xlsx_entry.insert(0, 'Export directory')

        signal1 = Entry(frame)
        signal1.grid(row=3, column=1, sticky=E)
        signal1.insert(0, 'Signal 1')

        sig1_line_left = Entry(frame)
        sig1_line_left.grid(row=4, column=1, sticky=E)
        sig1_line_left.insert(0, 0.5)

        sig1_line_right = Entry(frame)
        sig1_line_right.grid(row=5, column=1, sticky=E)
        sig1_line_right.insert(0, 1.5)

        sig1_polynom = Entry(frame)
        sig1_polynom.grid(row=6, column=1, sticky=E)
        sig1_polynom.insert(0, 4)

        sig1_int_span = Entry(frame)
        sig1_int_span.grid(row=7, column=1, sticky=E)
        sig1_int_span.insert(0, 0.4)

        sig1_peak_prom = Entry(frame)
        sig1_peak_prom.grid(row=8, column=1, sticky=E)
        sig1_peak_prom.insert(0, 50)

        sig1_peak_offset = Entry(frame)
        sig1_peak_offset.grid(row=9, column=1, sticky=E)
        sig1_peak_offset.insert(0, 0.7)

        sig1_small_peak_pos = Entry(frame)
        sig1_small_peak_pos.grid(row=10, column=1, sticky=E)
        sig1_small_peak_pos.insert(0, 0.9)

        signal2 = Entry(frame)
        signal2.grid(row=12, column=1, sticky=E)
        signal2.insert(0, 'Signal 2')

        sig2_line_left = Entry(frame)
        sig2_line_left.grid(row=13, column=1, sticky=E)
        sig2_line_left.insert(0, 1.9)

        sig2_line_right = Entry(frame)
        sig2_line_right.grid(row=14, column=1, sticky=E)
        sig2_line_right.insert(0, 2.6)

        sig2_polynom = Entry(frame)
        sig2_polynom.grid(row=15, column=1, sticky=E)
        sig2_polynom.insert(0, 4)

        sig2_int_span = Entry(frame)
        sig2_int_span.grid(row=16, column=1, sticky=E)
        sig2_int_span.insert(0, 0.2)

        sig2_peak_prom = Entry(frame)
        sig2_peak_prom.grid(row=17, column=1, sticky=E)
        sig2_peak_prom.insert(0, 50)

        sig2_peak_offset = Entry(frame)
        sig2_peak_offset.grid(row=18, column=1, sticky=E)
        sig2_peak_offset.insert(0, 0.5)

        sig2_small_peak_pos = Entry(frame)
        sig2_small_peak_pos.grid(row=19, column=1, sticky=E)
        sig2_small_peak_pos.insert(0, 2.16)

        signal3 = Entry(frame)
        signal3.grid(row=22, column=1, sticky=E)
        signal3.insert(0, 'Signal 3')

        sig3_line_left = Entry(frame)
        sig3_line_left.grid(row=23, column=1, sticky=E)
        sig3_line_left.insert(0, 2.7)

        sig3_line_right = Entry(frame)
        sig3_line_right.grid(row=24, column=1, sticky=E)
        sig3_line_right.insert(0, 3.3)

        sig3_polynom = Entry(frame)
        sig3_polynom.grid(row=25, column=1, sticky=E)
        sig3_polynom.insert(0, 6)

        sig3_int_span = Entry(frame)
        sig3_int_span.grid(row=26, column=1, sticky=E)
        sig3_int_span.insert(0, 0.2)

        sig3_line_peak_prom = Entry(frame)
        sig3_line_peak_prom.grid(row=27, column=1, sticky=E)
        sig3_line_peak_prom.insert(0, 5)

        sig3_peak_offset = Entry(frame)
        sig3_peak_offset.grid(row=28, column=1, sticky=E)
        sig3_peak_offset.insert(0, 0.7)

        sig3_small_peak_pos = Entry(frame)
        sig3_small_peak_pos.grid(row=29, column=1, sticky=E)
        sig3_small_peak_pos.insert(0, 2.93)

        signal4 = Entry(frame)
        signal4.grid(row=3, column=4, sticky=E)
        signal4.insert(0, 'Signal 4')
        
        sig4_line_left = Entry(frame)
        sig4_line_left.grid(row=4, column=4, sticky=E)
        sig4_line_left.insert(0, 8.7)

        sig4_line_right = Entry(frame)
        sig4_line_right.grid(row=5, column=4, sticky=E)
        sig4_line_right.insert(0, 10)

        sig4_polynom = Entry(frame)
        sig4_polynom.grid(row=6, column=4, sticky=E)
        sig4_polynom.insert(0, 4)

        sig4_int_span = Entry(frame)
        sig4_int_span.grid(row=7, column=4, sticky=E)
        sig4_int_span.insert(0, 0.4)

        sig4_line_peak_prom = Entry(frame)
        sig4_line_peak_prom.grid(row=8, column=4, sticky=E)
        sig4_line_peak_prom.insert(0, 500)

        sig4_peak_offset = Entry(frame)
        sig4_peak_offset.grid(row=9, column=4, sticky=E)
        sig4_peak_offset.insert(0, 0.7)

        sig4_small_peak_pos = Entry(frame)
        sig4_small_peak_pos.grid(row=10, column=4, sticky=E)
        sig4_small_peak_pos.insert(0, 6.19)

        signal5 = Entry(frame)
        signal5.grid(row=12, column=4, sticky=E)
        signal5.insert(0, 'Signal 5')

        sig5_line_left = Entry(frame)
        sig5_line_left.grid(row=13, column=4, sticky=E)
        sig5_line_left.insert(0, 12.1)

        sig5_line_right = Entry(frame)
        sig5_line_right.grid(row=14, column=4, sticky=E)
        sig5_line_right.insert(0, 13.2)

        sig5_polynom = Entry(frame)
        sig5_polynom.grid(row=15, column=4, sticky=E)
        sig5_polynom.insert(0, 4)

        sig5_int_span = Entry(frame)
        sig5_int_span.grid(row=16, column=4, sticky=E)
        sig5_int_span.insert(0, 0.3)

        sig5_line_peak_prom = Entry(frame)
        sig5_line_peak_prom.grid(row=17, column=4, sticky=E)
        sig5_line_peak_prom.insert(0, 500)

        sig5_peak_offset = Entry(frame)
        sig5_peak_offset.grid(row=18, column=4, sticky=E)
        sig5_peak_offset.insert(0, 0.7)

        sig5_small_peak_pos = Entry(frame)
        sig5_small_peak_pos.grid(row=19, column=4, sticky=E)
        sig5_small_peak_pos.insert(0, 12.35)

        signal6 = Entry(frame)
        signal6.grid(row=22, column=4, sticky=E)
        signal6.insert(0, 'Signal 6')

        sig6_line_left = Entry(frame)
        sig6_line_left.grid(row=23, column=4, sticky=E)
        sig6_line_left.insert(0, 13)

        sig6_line_right = Entry(frame)
        sig6_line_right.grid(row=24, column=4, sticky=E)
        sig6_line_right.insert(0, 13.8)

        sig6_polynom = Entry(frame)
        sig6_polynom.grid(row=25, column=4, sticky=E)
        sig6_polynom.insert(0, 4)

        sig6_int_span = Entry(frame)
        sig6_int_span.grid(row=26, column=4, sticky=E)
        sig6_int_span.insert(0, 0.4)

        sig6_line_peak_prom = Entry(frame)
        sig6_line_peak_prom.grid(row=27, column=4, sticky=E)
        sig6_line_peak_prom.insert(0, 500)

        sig6_peak_offset = Entry(frame)
        sig6_peak_offset.grid(row=28, column=4, sticky=E)
        sig6_peak_offset.insert(0, 0.7)

        sig6_small_peak_pos = Entry(frame)
        sig6_small_peak_pos.grid(row=29, column=4, sticky=E)
        sig6_small_peak_pos.insert(0, 13.55)

        export_name = Entry(frame)
        export_name.grid(row=31, column=1, sticky=E)
        export_name.insert(0, 'Table with integrals')

        Label(frame, text="Check integration parameters 1:").grid(row=2, column=0, sticky="nw")
        Label(frame, text="Signal 1 name:").grid(row=3, column=0, sticky="w")
        Label(frame, text="Left margin (min):").grid(row=4, column=0, sticky="w")
        Label(frame, text="Right margin (min):").grid(row=5, column=0, sticky="w")
        Label(frame, text="Baseline polynomial order:").grid(row=6, column=0, sticky="w")
        Label(frame, text="Peak half-width (min):").grid(row=7, column=0, sticky="w")
        Label(frame, text="Peak prominence:").grid(row=8, column=0, sticky="w")
        Label(frame, text="Peak distortion:").grid(row=9, column=0, sticky="w")
        Label(frame, text="Small peak position, min:").grid(row=10, column=0, sticky="w")

        # The two cells are reserved for any future functions
        Label(frame, text="Check integration parameters 2:").grid(row=11, column=0, sticky="nw")
        Label(frame, text="Signal 2 name:").grid(row=12, column=0, sticky="w")
        Label(frame, text="Left margin (min):").grid(row=13, column=0, sticky="w")
        Label(frame, text="Right margin (min):").grid(row=14, column=0, sticky="w")
        Label(frame, text="Baseline polynomial order:").grid(row=15, column=0, sticky="w")
        Label(frame, text="Peak half-width, (min):").grid(row=16, column=0, sticky="w")
        Label(frame, text="Peak prominence:").grid(row=17, column=0, sticky="w")
        Label(frame, text="Peak distortion:").grid(row=18, column=0, sticky="w")
        Label(frame, text="Small peak position, min:").grid(row=19, column=0, sticky="w")

        Label(frame, text="Check integration parameters 3:").grid(row=21, column=0, sticky="nw")
        Label(frame, text="SIgnal 3 name:").grid(row=22, column=0, sticky="w")
        Label(frame, text="Left margin (min):").grid(row=23, column=0, sticky="w")
        Label(frame, text="Right margin (min):").grid(row=24, column=0, sticky="w")
        Label(frame, text="Baseline polynomial order:").grid(row=25, column=0, sticky="w")
        Label(frame, text="Peak half-width, (min):").grid(row=26, column=0, sticky="w")
        Label(frame, text="Peak prominence:").grid(row=27, column=0, sticky="w")
        Label(frame, text="Peak distortion:").grid(row=28, column=0, sticky="w")
        Label(frame, text="Small peak position, min:").grid(row=29, column=0, sticky="w")

        Label(frame, text="Export data to xlsx:").grid(row=30, column=0, sticky="nw")
        Label(frame, text="Export file name:").grid(row=31, column=0, sticky="w")

        # Labels for hydrocarbons:

        Label(frame, text="Signal 4 name:").grid(row=3, column=2, sticky="w")
        Label(frame, text="Left margin (min):").grid(row=4, column=2, sticky="w")
        Label(frame, text="Right margin (min):").grid(row=5, column=2, sticky="w")
        Label(frame, text="Baseline polynomial order:").grid(row=6, column=2, sticky="w")
        Label(frame, text="Peak half-width (min):").grid(row=7, column=2, sticky="w")
        Label(frame, text="Peak prominence:").grid(row=8, column=2, sticky="w")
        Label(frame, text="Peak distortion:").grid(row=9, column=2, sticky="w")
        Label(frame, text="Small peak position, min:").grid(row=10, column=2, sticky="w")

        Label(frame, text="Signal 5 name:").grid(row=12, column=2, sticky="w")
        Label(frame, text="Left margin (min):").grid(row=13, column=2, sticky="w")
        Label(frame, text="Right margin (min):").grid(row=14, column=2, sticky="w")
        Label(frame, text="Baseline polynomial order:").grid(row=15, column=2, sticky="w")
        Label(frame, text="Peak half-width, (min):").grid(row=16, column=2, sticky="w")
        Label(frame, text="Peak prominence:").grid(row=17, column=2, sticky="w")
        Label(frame, text="Peak distortion:").grid(row=18, column=2, sticky="w")
        Label(frame, text="Small peak position, min:").grid(row=19, column=2, sticky="w")

        Label(frame, text="Signal 6 name:").grid(row=22, column=2, sticky="w")
        Label(frame, text="Left margin (min):").grid(row=23, column=2, sticky="w")
        Label(frame, text="Right margin (min):").grid(row=24, column=2, sticky="w")
        Label(frame, text="Baseline polynomial order:").grid(row=25, column=2, sticky="w")
        Label(frame, text="Peak half-width, (min):").grid(row=26, column=2, sticky="w")
        Label(frame, text="Peak prominence:").grid(row=27, column=2, sticky="w")
        Label(frame, text="Peak distortion:").grid(row=28, column=2, sticky="w")
        Label(frame, text="Small peak position, min:").grid(row=29, column=2, sticky="w")

        def get_integrator_object():
            '''The function extracts the data from object of Gui class, uses them as input for creating an instance of the Peakfinder class 
            and plots the figures from the data of this instance.'''
            a = data_entry.get()
            # The variables below are returned as strings
            sig1_left = sig1_line_left.get()
            sig1_right = sig1_line_right.get()
            sig1_pol = sig1_polynom.get()
            sig1_peak_width = sig1_int_span.get()
            sig1_l_prom = sig1_peak_prom.get()
            sig1_line_peak_distortion = sig1_peak_offset.get()
            sig1_small_peaks = sig1_small_peak_pos.get()

            sig2_left = sig2_line_left.get()
            sig2_right = sig2_line_right.get()
            sig2_pol = sig2_polynom.get()
            sig2_peak_width = sig2_int_span.get()
            sig2_l_prom = sig2_peak_prom.get()
            sig2_line_peak_distortion = sig2_peak_offset.get()
            sig2_small_peaks = sig2_small_peak_pos.get()

            sig3_left = sig3_line_left.get()
            sig3_right = sig3_line_right.get()
            sig3_pol = sig3_polynom.get()
            sig3_peak_width = sig3_int_span.get()
            sig3_l_prom = sig3_line_peak_prom.get()
            sig3_line_peak_distortion = sig3_peak_offset.get()
            sig3_small_peaks = sig3_small_peak_pos.get()

            sig4_left = sig4_line_left.get()
            sig4_right = sig4_line_right.get()
            sig4_pol = sig4_polynom.get()
            sig4_peak_width = sig4_int_span.get()
            sig4_l_prom = sig4_line_peak_prom.get()
            sig4_line_peak_distortion = sig4_peak_offset.get()
            sig4_small_peaks = sig4_small_peak_pos.get()

            sig5_left = sig5_line_left.get()
            sig5_right = sig5_line_right.get()
            sig5_pol = sig5_polynom.get()
            sig5_peak_width = sig5_int_span.get()
            sig5_l_prom = sig5_line_peak_prom.get()
            sig5_line_peak_distortion = sig5_peak_offset.get()
            sig5_small_peaks = sig5_small_peak_pos.get()

            sig6_left = sig6_line_left.get()
            sig6_right = sig6_line_right.get()
            sig6_pol = sig6_polynom.get()
            sig6_peak_width = sig6_int_span.get()
            sig6_l_prom = sig6_line_peak_prom.get()
            sig6_line_peak_distortion = sig6_peak_offset.get()
            sig6_small_peaks = sig6_small_peak_pos.get()

            signal1_name = signal1.get()
            signal2_name = signal2.get()
            signal3_name = signal3.get()
            signal4_name = signal4.get()
            signal5_name = signal5.get()
            signal6_name = signal6.get()

            print(1000*(time.time() - start))

            a = PeakFinder(str(a), sig1_left=float(sig1_left), sig1_right=float(sig1_right), sig2_left=float(sig2_left),
                           sig2_right=float(sig2_right), sig3_left=float(sig3_left), sig3_right=float(sig3_right),
                           sig4_left=float(sig4_left), sig4_right=float(sig4_right), sig5_left=float(sig5_left),
                           sig5_right=float(sig5_right), sig6_left=float(sig6_left), sig6_right=float(sig6_right),
                           sig1_baseline_polynom_order=int(sig1_pol), sig2_baseline_polynom_order=int(sig2_pol),
                           sig3_baseline_polynom_order=int(sig3_pol), sig4_baseline_polynom_order=int(sig4_pol),
                           sig5_baseline_polynom_order=int(sig5_pol), sig6_baseline_polynom_order=int(sig6_pol),
                           sig1_peak_prominence=float(sig1_l_prom), sig2_peak_prominence=float(sig2_l_prom),
                           sig3_peak_prominence=float(sig3_l_prom), sig4_peak_prominence=float(sig4_l_prom),
                           sig5_peak_prominence=float(sig5_l_prom), sig6_peak_prominence=float(sig6_l_prom),
                           sig1_peak_width=float(sig1_peak_width), sig2_peak_width=float(sig2_peak_width),
                           sig3_peak_width=float(sig3_peak_width), sig4_peak_width=float(sig4_peak_width),
                           sig5_peak_width=float(sig5_peak_width), sig6_peak_width=float(sig6_peak_width),
                           sig1_small_peaks_pos=float(sig1_small_peaks), sig2_small_peaks_pos=float(sig2_small_peaks),
                           sig3_small_peaks_pos=float(sig3_small_peaks), sig4_small_peaks_pos=float(sig4_small_peaks),
                           sig5_small_peaks_pos=float(sig5_small_peaks), sig6_small_peaks_pos=float(sig6_small_peaks),
                           sig1_peak_distortion=float(sig1_line_peak_distortion),
                           sig2_peak_distortion=float(sig2_line_peak_distortion),
                           sig3_peak_distortion=float(sig3_line_peak_distortion),
                           sig4_peak_distortion=float(sig4_line_peak_distortion),
                           sig5_peak_distortion=float(sig5_line_peak_distortion),
                           sig6_peak_distortion=float(sig6_line_peak_distortion))

            print(1000 * (time.time() - start))

            fig = Figure(figsize=(11, 8))
            fig.suptitle('Review the baseline fitting, peak positions and integration boundaries')

            gs = fig.add_gridspec(2, 4)
            gs.update(left=0.07, right=0.97, wspace=0.35, hspace=0.25, top=0.92, bottom=0.1)

            f_ax1 = fig.add_subplot(gs[0, 0])
            f_ax2 = fig.add_subplot(gs[0, 1])
            f_ax3 = fig.add_subplot(gs[0, 2])
            f_ax4 = fig.add_subplot(gs[0, 3])
            f_ax5 = fig.add_subplot(gs[1, 0])
            f_ax6 = fig.add_subplot(gs[1, 1])
            f_ax7 = fig.add_subplot(gs[1, 2])
            f_ax8 = fig.add_subplot(gs[1, 3])

            plot_chromatogram(f_ax1, a.sig1_curves, a.sig1_peaks, a.sig1_baselines, sig1_peak_width, a.sig1_peak_offset)
            plot_chromatogram(f_ax2, a.sig2_curves, a.sig2_peaks, a.sig2_baselines, sig2_peak_width, a.sig2_peak_offset)
            plot_chromatogram(f_ax3, a.sig3_curves, a.sig3_peaks, a.sig3_baselines, sig3_peak_width, a.sig3_peak_offset)
            plot_chromatogram(f_ax5, a.sig4_curves, a.sig4_peaks, a.sig4_baselines, sig4_peak_width, a.sig4_peak_offset)
            plot_chromatogram(f_ax6, a.sig5_curves, a.sig5_peaks, a.sig5_baselines, sig5_peak_width,
                              a.sig5_peak_offset)
            plot_chromatogram(f_ax7, a.sig6_curves, a.sig6_peaks, a.sig6_baselines, sig6_peak_width,
                              a.sig6_peak_offset)

            sig1_ints, sig2_ints, sig3_ints = a.sig1_integrals, a.sig2_integrals, a.sig3_integrals
            run_num_sig1, run_num_sig2, run_num_sig3 = np.linspace(1, len(sig1_ints), len(sig1_ints)), \
                                                 np.linspace(1, len(sig2_ints), len(sig2_ints)), \
                                                 np.linspace(1, len(sig3_ints), len(sig3_ints))

            f_ax4.plot(run_num_sig1, sig1_ints, ls=':', lw=1, c='red', marker='o', ms=5, mec='black', label=f'{signal1_name} peak area')
            f_ax4.plot(run_num_sig2, sig2_ints, ls=':', lw=1, c='green', marker='o', ms=5, mec='black',
                       label=f'{signal2_name} peak area')
            f_ax4.plot(run_num_sig3, sig3_ints, ls=':', lw=1, c='blue', marker='o', ms=5, mec='black', label=f'{signal3_name} peak area')
            f_ax4.legend(frameon=False)

            sig4_ints, sig5_ints, sig6_ints = a.sig4_integrals, a.sig5_integrals, a.sig6_integrals
            run_num_sig4, run_num_sig5, run_num_sig6 = np.linspace(1, len(sig4_ints), len(sig4_ints)), \
                                                      np.linspace(1, len(sig5_ints), len(sig5_ints)), \
                                                      np.linspace(1, len(sig6_ints), len(sig6_ints))

            f_ax8.plot(run_num_sig4, sig4_ints, ls=':', lw=1, c='red', marker='o', ms=5, mec='black',
                       label=f'{signal4_name} peak area')
            f_ax8.plot(run_num_sig5, sig5_ints, ls=':', lw=1, c='green', marker='o', ms=5, mec='black',
                       label=f'{signal5_name} peak area')
            f_ax8.plot(run_num_sig6, sig6_ints, ls=':', lw=1, c='blue', marker='o', ms=5, mec='black',
                       label=f'{signal6_name} peak area')
            f_ax8.legend(frameon=False)

            f_ax1.title.set_text(f'{signal1_name}')
            f_ax2.title.set_text(f'{signal2_name}')
            f_ax3.title.set_text(f'{signal3_name}')
            f_ax5.title.set_text(f'{signal4_name}')
            f_ax6.title.set_text(f'{signal5_name}')
            f_ax7.title.set_text(f'{signal6_name}')

            f_ax4.set_facecolor('lavender')
            f_ax4.set_ylabel('integral')
            f_ax4.set_xlabel('injection number')
            f_ax4.title.set_text('Integration results')

            f_ax8.set_facecolor('lavender')
            f_ax8.set_ylabel('integral')
            f_ax8.set_xlabel('injection number')
            f_ax8.title.set_text('Integration results')

            # fig.tight_layout()

            canvas = FigureCanvasTkAgg(fig, root)
            canvas.get_tk_widget().grid(row=0, column=1)

            toolbarframe = Frame(master=root)
            toolbarframe.grid(row=1, column=1)
            NavigationToolbar2Tk(canvas, toolbarframe)

        def export_data():
            '''The function starts working after pushing 'Export data'. The function extracts the data from object of Gui class, uses them 
            as input for creating an instance of the Peakfinder class and exports the integrals from this instance into xlsx file.'''
            a = data_entry.get()
            signal1_name = signal1.get()
            sig1_left = sig1_line_left.get()
            sig1_right = sig1_line_right.get()
            sig1_pol = sig1_polynom.get()
            sig1_peak_width = sig1_int_span.get()
            sig1_l_prom = sig1_peak_prom.get()
            sig1_line_peak_distortion = sig1_peak_offset.get()
            sig1_small_peaks = sig1_small_peak_pos.get()

            signal2_name = signal2.get()
            sig2_left = sig2_line_left.get()
            sig2_right = sig2_line_right.get()
            sig2_pol = sig2_polynom.get()
            sig2_peak_width = sig2_int_span.get()
            sig2_l_prom = sig2_peak_prom.get()
            sig2_line_peak_distortion = sig2_peak_offset.get()
            sig2_small_peaks = sig2_small_peak_pos.get()

            signal3_name = signal3.get()
            sig3_left = sig3_line_left.get()
            sig3_right = sig3_line_right.get()
            sig3_pol = sig3_polynom.get()
            sig3_peak_width = sig3_int_span.get()
            sig3_l_prom = sig3_line_peak_prom.get()
            sig3_line_peak_distortion = sig3_peak_offset.get()
            sig3_small_peaks = sig3_small_peak_pos.get()

            signal4_name = signal4.get()
            sig4_left = sig4_line_left.get()
            sig4_right = sig4_line_right.get()
            sig4_pol = sig4_polynom.get()
            sig4_peak_width = sig4_int_span.get()
            sig4_l_prom = sig4_line_peak_prom.get()
            sig4_line_peak_distortion = sig4_peak_offset.get()
            sig4_small_peaks = sig4_small_peak_pos.get()

            
            signal5_name = signal5.get()
            sig5_left = sig5_line_left.get()
            sig5_right = sig5_line_right.get()
            sig5_pol = sig5_polynom.get()
            sig5_peak_width = sig5_int_span.get()
            sig5_l_prom = sig5_line_peak_prom.get()
            sig5_line_peak_distortion = sig5_peak_offset.get()
            sig5_small_peaks = sig5_small_peak_pos.get()

            signal6_name = signal6.get()
            sig6_left = sig6_line_left.get()
            sig6_right = sig6_line_right.get()
            sig6_pol = sig6_polynom.get()
            sig6_peak_width = sig6_int_span.get()
            sig6_l_prom = sig6_line_peak_prom.get()
            sig6_line_peak_distortion = sig6_peak_offset.get()
            sig6_small_peaks = sig6_small_peak_pos.get()

            a = PeakFinder(str(a), sig1_left=float(sig1_left), sig1_right=float(sig1_right), sig2_left=float(sig2_left),
                           sig2_right=float(sig2_right), sig3_left=float(sig3_left), sig3_right=float(sig3_right),
                           sig4_left=float(sig4_left), sig4_right=float(sig4_right), sig5_left=float(sig5_left),
                           sig5_right=float(sig5_right), sig6_left=float(sig6_left), sig6_right=float(sig6_right),
                           sig1_baseline_polynom_order=int(sig1_pol), sig2_baseline_polynom_order=int(sig2_pol),
                           sig3_baseline_polynom_order=int(sig3_pol), sig4_baseline_polynom_order=int(sig4_pol),
                           sig5_baseline_polynom_order=int(sig5_pol), sig6_baseline_polynom_order=int(sig6_pol),
                           sig1_peak_prominence=float(sig1_l_prom), sig2_peak_prominence=float(sig2_l_prom),
                           sig3_peak_prominence=float(sig3_l_prom), sig4_peak_prominence=float(sig4_l_prom),
                           sig5_peak_prominence=float(sig5_l_prom), sig6_peak_prominence=float(sig6_l_prom),
                           sig1_peak_width=float(sig1_peak_width), sig2_peak_width=float(sig2_peak_width),
                           sig3_peak_width=float(sig3_peak_width), sig4_peak_width=float(sig4_peak_width),
                           sig5_peak_width=float(sig5_peak_width), sig6_peak_width=float(sig6_peak_width),
                           sig1_small_peaks_pos=float(sig1_small_peaks), sig2_small_peaks_pos=float(sig2_small_peaks),
                           sig3_small_peaks_pos=float(sig3_small_peaks), sig4_small_peaks_pos=float(sig4_small_peaks),
                           sig5_small_peaks_pos=float(sig5_small_peaks), sig6_small_peaks_pos=float(sig6_small_peaks),
                           sig1_peak_distortion=float(sig1_line_peak_distortion),
                           sig2_peak_distortion=float(sig2_line_peak_distortion),
                           sig3_peak_distortion=float(sig3_line_peak_distortion),
                           sig4_peak_distortion=float(sig4_line_peak_distortion),
                           sig5_peak_distortion=float(sig5_line_peak_distortion),
                           sig6_peak_distortion=float(sig6_line_peak_distortion))
            sig1_ints = a.sig1_integrals
            sig2_ints = a.sig2_integrals
            sig3_ints = a.sig3_integrals
            sig4_ints = a.sig4_integrals
            sig5_ints = a.sig5_integrals
            sig6_ints = a.sig6_integrals
            export_path = xlsx_entry.get()
            name = export_name.get() + '.xlsx'
            df = pd.DataFrame({f'{signal1_name}': sig1_ints, f'{signal2_name}': sig2_ints, f'{signal3_name}': sig3_ints, 
                                f'{signal4_name}': sig4_ints, f'{signal5_name}': sig5_ints, f'{signal6_name}': sig6_ints})
            path = os.path.join(export_path, name)
            df.to_excel(path)

        def _quit():
            root.quit()  # stops mainloop, widgets can be accessed
            root.destroy()  # stops mainloop, widgets can not be accessed

        Button(frame, text="Review plots", bg="lavender", command=get_integrator_object).grid(row=32, column=1, sticky="we")                                                                                             
        Button(frame, text="Export .xlsx data", bg="lavender", command=export_data).grid(row=33, column=1, sticky="we")
        Button(frame, text="Exit", command=_quit, bg="oldlace").grid(row=34, column=1, sticky="we")


if __name__ == '__main__':
    root = Tk()
    gui = Gui(root)
    root.mainloop()
